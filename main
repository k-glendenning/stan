#!/bin/bash

source configuration
myuser=$(echo "$mynick" | tr '[A-Z]' '[a-z]')
startup=$(date +%s)
lastline=0
shutupline=0
linecount=0
match() { echo -E "$1" | perl -ne "if (\$_ =~ /^[:@](?:[^[a-zA-Z\[\]_]]+ )?([^\s]+) (([^:\s](?:[^\s])* ?)*)?(?: ?:(.*))?$/){print $2}" | tr -d '\r\n'; }
getcmd() { echo -E "$1" | perl -ne "if (\$_ =~ /^[$trigger]((?:[a-z][a-z]+)) ?((?:.*))?/){print $2}"; }
clean() { echo -E "$1" | sed 's/\o001//g'; }
send() { out=$(clean "$1"); echo -E "< $out"; echo -E "$out" >&3; }
say() { send "PRIVMSG $1 :$2"; }

# Connect
exec 3<>/dev/tcp/$server/$port
send "NICK $mynick"
send "USER $myuser x x :Bashful IRC Bot"

while :; do
   read line <&3
   echo "> $line"

   # PING / PONG
   if [[ $line =~ "PING" ]]; then
      send "PONG ${line:5}"
   # Identify and join channel(s)
   elif [[ $line =~ "376" ]]; then
      say 'NickServ' "identify $pass"
      echo '* Sleep (2)...'
      sleep 2
      for chan in ${mychans[@]}; do
         send "JOIN $chan"
      done
   fi

   number=$RANDOM
   # Sender's full usermask
   mask=$(match "$line" '$1')
   # Ignore useless input
   if [ -z "$mask" ]; then
      continue
   fi
   # Sender's nick
   nick=(${mask//!/ })
   host=${nick[1]}
   nick=${nick[0]}
   # Recipient / channel
   chan=$(match "$line" '$3' | tr -d ' ')
   # If the channel is me, then set the channel to the sender's nick
   if [ "$chan" = "$mynick" ]; then
      chan=$nick
   fi
   # Message body
   msg=$(match "$line" '$4')

   # Check if the message is a command.
   cmd=$(getcmd "$msg" '$1')
   if [ -z "$cmd" ]; then
      if [ -z "$host" ] || (echo ${ignore[@]} | grep -qi $nick); then
         continue
      fi
      let "number %= $randint"
      if [ $number -eq 67 ] || (echo $msg | grep -qi "\b$mynick\b"); then
         thisline=$(date +%s)
         # "Shut up" handling
         delta=$(($thisline - $shutupline))
         if [ $delta -le $sleeptime ]; then
            continue
         fi

         # Time / line limit handling
         delta=$(($thisline - $lastline))
         # Both limits have been hit.
         if [ $delta -le $floodtime ] && [ $linecount -gt $floodlines ]; then
            continue
         # Time limit has been hit but line limit hasn't been hit. Increment line count.
         elif [ $delta -le $floodtime ] && [ $linecount -le $floodlines ]; then
            let 'linecount+=1'
         # Time limit has passed. Reset line count.
         elif [ $delta -gt $floodtime ]; then
            linecount=0
         fi

         say "$chan" "$(cat stan/brain.db | python2 stan/markov.py $msg)"
         lastline=$(date +%s)
      fi
      let "number %= $randwrite"
      if [ $number -eq 7 ]; then
         echo '* Learning...'
         (echo "$msg" | stan/split.pl) >> stan/brain.db
      fi
      continue
   fi
   # Full command arguments as a string
   args=$(getcmd "$msg" '$2')
   # Command arguments as an array
   arg=(${args// / })
   
   # Normal command hook
   case "$cmd" in
      up|uptime)
         now=$(date +%s)
         delta=$(($(($now-$startup))/60))
         say "$chan" "About $delta minutes"
         unset now delta
         ;;
      help)
         say "$chan" 'See https://wiki.interlinked.me/page/Stan'
         ;;
      sleep)
         say "$chan" 'Okay.'
         shutupline=$(date +%s)
         ;;
      wake)
         say "$chan" 'HELLO'
         shutupline=0
         ;;
   esac

   # Modular command hook
   if [ -e "modules/$cmd.py" ]; then
      say "$chan" "$(python3 modules/$cmd.py $args)"
   fi

   # Priviledged command hook
   if [ "$mask" = "$owner" ]; then
      case "$cmd" in
         quit)
            echo '* Exiting...'
            send 'QUIT :No reason'
            break
            ;;
         join)
            send "JOIN $args"
            ;;
         part)
            send "PART $args"
            ;;
         nick)
            mynick=${arg[0]}
            send "NICK ${arg[0]}"
            ;;
         say)
            saying=${arg[@]:1}
            say "${arg[0]}" "$saying"
            ;;
         reload)
            source configuration
            say "$chan" 'Reload complete.'
            ;;
         sed)
            sed -i.bak "$args" stan/brain.db
            changes=$(diff -U 0 stan/brain.db.bak stan/brain.db | grep ^@ | wc -l)
            say "$chan" "$changes line(s) were modified."
            ;;
         let)
            let "$args" &>/tmp/stan-let
            changes=$(cat /tmp/stan-let)
            if [ -z "$changes" ]; then
               changes='Okay.'
            fi
            say "$chan" "$changes"
            rm /tmp/stan-let
            ;;
      esac
   fi
   unset mask nick chan cmd args arg
done
